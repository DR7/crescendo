/*
 *
  Adelyte Company
  www.adelyte.com
 *
 */

// Compiler Directives
#SYMBOL_NAME "Yahoo! Weather"
#CATEGORY "8" // Media Resource
#DEFAULT_VOLATILE
#ENABLE_DYNAMIC // Dynamic arrays are NOT used, but supposedly this directive improves memory allocation.
#ENABLE_TRACE
#USER_LIBRARY "lib xml"


// Help
#HELP_BEGIN
Yahoo! Weather

Released by Adelyte Company into the public domain under the Creative Commons Zero license.

Authors:
  - David Massey (lead) <david@adelyte.com>
  - Chris Massey <chris@adelyte.com>

#HELP_END


// Constants
#DEFINE_CONSTANT #YES 1
#DEFINE_CONSTANT #NO  0

#DEFINE_CONSTANT #FORECAST_DAYS 5

#DEFINE_CONSTANT #ADDRESS_LEN    32 // xml.weather.yahoo.com
#DEFINE_CONSTANT #WEATHER_LEN  4096
#DEFINE_CONSTANT #BUFFER_LEN   8192 // #WEATHER_LEN * 2
#DEFINE_CONSTANT #LOCATION_LEN   26 // LEN("Rancho Santa Margarita, CA")
#DEFINE_CONSTANT #ZIP_CODE_LEN    5
                                                                                                                                 
#DEFINE_CONSTANT #MAX_PRESETS 12

/*
 *
  Inputs and Outputs
 *
 */

// System Integration
DIGITAL_INPUT in_Update;
ANALOG_INPUT  in_Time;

DIGITAL_INPUT in_Temperature_Sensor_Enable;
ANALOG_INPUT  in_Temperature_Sensor;

ANALOG_OUTPUT  out_Lat_Degrees, out_Lat_Minutes;
DIGITAL_OUTPUT out_Lat_Is_North;
ANALOG_OUTPUT  out_Long_Degrees, out_Long_Minutes;
DIGITAL_OUTPUT out_Long_Is_East;

// Numpad
DIGITAL_INPUT  in_Enter, in_Clear, in_Backspace;
DIGITAL_INPUT  in_Numpad[10];
DIGITAL_OUTPUT out_Numpad_Open;
STRING_OUTPUT  out_Numpad;

// Weather Data
ANALOG_OUTPUT out_Current_Temp, out_Current_Image;
STRING_OUTPUT out_Current_Temp_Text, out_Current_Conditions;

ANALOG_OUTPUT out_Wind_Chill, out_Wind_Speed, out_Wind_Direction;
STRING_OUTPUT out_Wind_Chill_Text, out_Wind_Speed_Text, out_Wind_Direction_Text, out_Wind_Full_Description;

ANALOG_OUTPUT out_Humidity, out_Pressure;
STRING_OUTPUT out_Humidity_Text, out_Pressure_Text;

STRING_OUTPUT out_Sunrise_Text, out_Sunset_Text;
ANALOG_OUTPUT out_Sunrise, out_Sunset;

STRING_OUTPUT out_City, out_State, out_Country;
STRING_OUTPUT out_Location;

STRING_OUTPUT out_Last_Build;

ANALOG_OUTPUT out_Forecast_High[#FORECAST_DAYS], out_Forecast_Low[#FORECAST_DAYS], out_Forecast_Image[#FORECAST_DAYS];
STRING_OUTPUT out_Forecast_High_Text[#FORECAST_DAYS], out_Forecast_Low_Text[#FORECAST_DAYS], out_Forecast_Description[#FORECAST_DAYS], out_Forecast_Date[#FORECAST_DAYS];

// Presets
DIGITAL_INPUT in_Preset[#MAX_PRESETS, #MAX_PRESETS];
STRING_OUTPUT out_Preset_ZIP_Code[#MAX_PRESETS];
STRING_OUTPUT out_Preset_Location[#MAX_PRESETS];

/*
 *
  Parameters
 *
 */

STRING_PARAMETER param_ZIP_Code[#ZIP_CODE_LEN];
#BEGIN_PARAMETER_PROPERTIES param_ZIP_Code

  propSHORTDESCRIPTION = "ZIP Code for automatically updated weather report.";

#END_PARAMETER_PROPERTIES

STRING_PARAMETER param_Units[1];
#BEGIN_PARAMETER_PROPERTIES param_Units

  propSHORTDESCRIPTION = "Temperature units as Fahrenheit or Celsius.";

#END_PARAMETER_PROPERTIES

INTEGER_PARAMETER param_Hold_Time;
#BEGIN_PARAMETER_PROPERTIES param_Hold_Time

  propVALIDUNITS  = unitDecimal|unitTime;
  propDEFAULTUNIT = unitDecimal;
  propSHORTDESCRIPTION = "Time to wait to set preset in hundredths of a second.";

#END_PARAMETER_PROPERTIES

/*
 *
  TCP Socket
 *
 */

TCP_CLIENT struct_TCP[#BUFFER_LEN];

/*
 *
  Functions
 *
 */

// Global Data
STRING  ZipCode[#ZIP_CODE_LEN], Location[#LOCATION_LEN];
STRING  LastModified[32];


// String Parsing
SIGNED_INTEGER_FUNCTION ATOSINew(STRING ascii_string) // Converts a STRING to a SIGNED_INTEGER.
{
  SIGNED_INTEGER int, pos;
  
  int = ATOI(ascii_string);
  pos = FIND(ITOA(int), ascii_string);
  
  IF(pos > 1)
  {
    IF(BYTE(ascii_string, pos - 1) = 0x2D) // 0x2D = "-"
    {
      int = -1 * int;
    }
  }
  
  RETURN(int);
}

INTEGER_FUNCTION TIMETOI(STRING tod)
{
  INTEGER minutes;
  
  minutes = ATOI(LEFT(tod, 2));
  minutes = minutes * 60;
  minutes = minutes + ATOI(RIGHT(tod, LEN(tod) - 2));
  
  IF(RIGHT(tod, 2) = "pm")
    minutes = minutes + 720;
  
  RETURN(minutes);
}


// TCP Client
INTEGER ConnectWaitActive;

FUNCTION ConnectToServer(INTEGER wait_time)
{
  SIGNED_INTEGER returned_value;
  TRACE("Weather | Connect(wait_time = %u)", wait_time);
  SOCKETDISCONNECTCLIENT(struct_TCP); // Must be disconnected before a new connection can be established.
  
  IF(wait_time > 0)
  {
    IF(ConnectWaitActive = #NO)
    {
      WAIT(wait_time, CONNECT_WAIT)
      {
        SOCKETCONNECTCLIENT(struct_TCP, "weather.yahooapis.com", 80, #NO);
      }
    }
    ELSE
    {
      RETIMEWAIT(wait_time, CONNECT_WAIT);
    }
  }
  ELSE
  {
    SOCKETCONNECTCLIENT(struct_TCP, "weather.yahooapis.com", 80, #NO);
  }
}

SOCKETCONNECT struct_TCP
{
  STRING connected_address[#ADDRESS_LEN];
  STRING tcp_tx[#BUFFER_LEN];
  
  SOCKETGETADDRESSASREQUESTED(struct_TCP, connected_address);
  TRACE("Weather | SOCKETCONNECT(%s)", connected_address);
  
  MAKESTRING(tcp_tx, "GET /forecastrss?p=%s&u=%s HTTP/1.1\nHost: weather.yahooapis.com\n\n", ZipCode, param_Units); // The feed does not provide a Last-Modified header field and seems to ignore the If-Modified-Since header field.

  SOCKETSEND(struct_TCP, tcp_tx);
  TRACE("Weather | SOCKETSEND('%s')", tcp_tx);
}

SOCKETSTATUS struct_TCP
{                
  STRING connected_address[#ADDRESS_LEN];
  
  SOCKETGETADDRESSASREQUESTED(struct_TCP, connected_address);
  TRACE("Weather | SOCKETSTATUS(%s) = %u", connected_address, struct_TCP.SocketStatus);
  
  IF(struct_TCP.SocketStatus = 3) // TCP connection failed, wait one minute and retry.
  {
    TRACE("ERROR in %s 'Yahoo! Weather Logic.usp': TCP Connection Failed", GETSYMBOLINSTANCENAME());
    ConnectToServer(6000);
  }
  ELSE IF(struct_TCP.SocketStatus = 7) // DNS lookup failed, wait one minute and retry.
  {
    TRACE("ERROR in %s 'Yahoo! Weather Logic.usp': DNS Lookup Failed", GETSYMBOLINSTANCENAME());
    ConnectToServer(6000);
  }
  ELSE
  {
    // Pass
  }
}


// Numpad
STRING Numpad[#ZIP_CODE_LEN];

PUSH in_Numpad
{
  INTEGER numpad_index;

  numpad_index = GETLASTMODIFIEDARRAYINDEX() - 1; // Map in_Numpad[1..10] to 0..9

  IF(LEN(Numpad) < #ZIP_CODE_LEN)
    MAKESTRING(Numpad, "%s%u", Numpad, numpad_index);
  ELSE
    TERMINATEEVENT;

  out_Numpad = Numpad;
}

PUSH in_Enter
{
  ZipCode = Numpad;
  
  ConnectToServer(0);
}

PUSH in_Enter, in_Clear
{
  Numpad = "";
  out_Numpad = Numpad;
}

PUSH in_Backspace
{
  IF(LEN(Numpad) > 1)
    MAKESTRING(Numpad, "%s", LEFT(Numpad, LEN(Numpad) - 1));
  ELSE
    Numpad = "";
  
  out_Numpad = Numpad;
}

// Presets
NONVOLATILE STRING PresetZipCodes[#MAX_PRESETS][#ZIP_CODE_LEN], PresetLocations[#MAX_PRESETS][#LOCATION_LEN];

INTEGER PresetWaitActive, PresetIndex;

PUSH in_Preset
{
  PresetIndex = GETLASTMODIFIEDARRAYINDEX();
  
  IF(PresetWaitActive = #NO)
  {
    PresetWaitActive = #YES;
    
    WAIT(param_Hold_Time, PRESET_WAIT)
    {
      PresetZipCodes[PresetIndex] = ZipCode;
      out_Preset_ZIP_Code[PresetIndex] = PresetZipCodes[PresetIndex];
      
      PresetLocations[PresetIndex] = Location;
      out_Preset_Location[PresetIndex] = PresetLocations[PresetIndex];
      
      PresetWaitActive = #NO;
    }
  }
  ELSE
  {
    TRACE("ERROR in %s 'weather logic.usp': Multiple Simultaneous Presets", GETSYMBOLINSTANCENAME());
  }
}

RELEASE in_Preset
{
  PresetIndex = GETLASTMODIFIEDARRAYINDEX();
  
  IF(PresetWaitActive = #YES)
  {
    CANCELWAIT(PRESET_WAIT);
    PresetWaitActive = #No;
    
    ZipCode = PresetZipCodes[PresetIndex];
    
    ConnectToServer(0);
  }
  ELSE
  {
    // Pass
  }
}


// System Integration
#DEFINE_CONSTANT #UPDATE_INTERVAL 10

PUSH in_Update
{
  ConnectToServer(0);
}

CHANGE in_Time
{
  INTEGER minutes;
  
  minutes = in_Time MOD 15;
  
  IF(minutes = 0)
  {
    ConnectToServer(0);
  }
}

CHANGE in_Temperature_Sensor
{
  STRING units[2];
  
  IF(in_Temperature_Sensor_Enable = #YES)
  {
	  IF(param_Units = "f")
	    MAKESTRING(units, "%c", 0xB0);
	  ELSE IF(param_Units = "c")
	    MAKESTRING(units, "%c", 0xB0);
	  ELSE
	    units = "";
    
    out_Current_Temp = in_Temperature_Sensor;
    MAKESTRING(out_Current_Temp_Text, "%d%s", in_Temperature_Sensor, units);
  }
}


// Parse & Display Weather

INTEGER_FUNCTION GetImage(INTEGER condition)
{
  SWITCH(condition)
  {
    CASE(0): // Tornado.
      RETURN(24);
    CASE(1): // Tropical storm.
      RETURN(17);
    CASE(2): // Hurricane.
      RETURN(17);
    CASE(3): // Severe thunderstorms.
      RETURN(17);
    CASE(4): // Thunderstorms.
      RETURN(17);
    CASE(5): // Mixed rain and snow.
      RETURN(22);
    CASE(6): // Mixed rain and sleet.
      RETURN(22);
    CASE(7): // Mixed snow and sleet.
      RETURN(22);
    CASE(8): // Freezing drizzle.
      RETURN(22);
    CASE(9): // Drizzle.
      RETURN(15);
    CASE(10): // Freezy rain.
      RETURN(22);
    CASE(11): // Showers.
      RETURN(16);
    CASE(12): // Showers.
      RETURN(16);
    CASE(13): // Snow flurries.
      RETURN(19);
    CASE(14): // Light snow showers.
      RETURN(19);
    CASE(15): // Blowing snow.
      RETURN(20);
    CASE(16): // Snow.
      RETURN(20);
    CASE(17): // Hail.
      RETURN(23);
    CASE(18): // Sleet.
      RETURN(22);
    CASE(19): // Dust.
      RETURN(25);
    CASE(20): // Foggy.
      RETURN(25);
    CASE(21): // Haze.
      RETURN(25);
    CASE(22): // Smokey.
      RETURN(25);
    CASE(23): // Blustery.
      RETURN(24);
    CASE(24): // Windy.
      RETURN(24);
    CASE(25): // Cold.
      RETURN(21);
    CASE(26): // Cloudy.
      RETURN(14);
    CASE(27): // Mostly cloudy (night).
      RETURN(10);
    CASE(28): // Mostly cloudy (day).
      RETURN(4);
    CASE(29): // Partly cloudy (night).
      RETURN(9);
    CASE(30): // Partly cloudy (day).
      RETURN(3);
    CASE(31): // Clear (night).
      RETURN(7);
    CASE(32): // Sunny
      RETURN(1);
    CASE(33): // Fair (night).
      RETURN(8);
    CASE(34): // Fair (day).
      RETURN(2);
    CASE(35): // Mixed rain and hail.
      RETURN(23);
    CASE(36): // Hot.
      RETURN(1);
    CASE(37): // Isolated thunderstorms.
      RETURN(17);
    CASE(38): // Scattered thunderstorms.
      RETURN(17);
    CASE(39): // Scattered thunderstorms.
      RETURN(17);
    CASE(40): // Scattered showers.
      RETURN(16);
    CASE(41): // Heavy snow.
      RETURN(20);
    CASE(42): // Scattered snow showers.
      RETURN(19);
    CASE(43): // Heavy snow.
      RETURN(20);
    CASE(44): // Partly cloudy.
      RETURN(14);
    CASE(45): // Thundershowers.
      RETURN(18);
    CASE(46): // Snow showers.
      RETURN(20);
    CASE(47): // Isolated thundershowers.
      RETURN(18);
    DEFAULT:
      RETURN(0);
  }
}

FUNCTION ProcessRX(STRING received)
{
  STRING element_names[2][24], content[128], attributes[128];
  STRING city[22], state[2], country[12];
  STRING units[4], wind_direction_text[18], tod[8];
  INTEGER find_pos, wind_direction;
  INTEGER forecast_day;
    
  SETARRAY(element_names, "");
  element_names[0] = "channel";
  
  IF(FIND("Error", received))
  {
    out_Last_Build = "Error";
    
    element_names[1] = "item";
    element_names[2] = "title";
    
    XMLGetElementData(element_names, 1, received, content, attributes);
    
    out_Current_Conditions  = content;
    RETURN;
  }            
  
  // Last Build
  element_names[1] = "lastBuildDate";
  XMLGetElementData(element_names, 1, received, content, attributes);
  
  out_Last_Build = content;
  LastModified = content;
  
  // Location
  element_names[1] = "yweather:location";
  XMLGetElementData(element_names, 1, received, content, attributes);
  
  city    = XMLGetAttributeData("city", attributes);
  state   = XMLGetAttributeData("region", attributes);
  country = XMLGetAttributeData("country", attributes);
  
  out_City    = city;
  out_State   = state;
  out_Country = country;
  MAKESTRING(Location, "%s, %s %s", city, state, country);
  out_Location = Location;
    
  // Wind
  element_names[1] = "yweather:wind";
  XMLGetElementData(element_names, 1, received, content, attributes);
  
  out_Wind_Chill = ATOSINew(XMLGetAttributeData("chill", attributes));
  out_Wind_Speed = ATOI(XMLGetAttributeData("speed", attributes));
  
  wind_direction = ATOI(XMLGetAttributeData("direction", attributes));
  
  // Scale wind direct in degrees to 16 cardinal directions.
  wind_direction = wind_direction * 16;
  wind_direction = wind_direction + 180; // Center direction on +/- 11.25 degrees.
  wind_direction = wind_direction / 360;
  wind_direction = wind_direction MOD 16 + 1;
  out_Wind_Direction = wind_direction;
  
  // Wind Direction
  SWITCH(out_Wind_Direction)
  {
    CASE(0):
      wind_direction_text = "Calm";
    CASE(1):
      wind_direction_text = "North";
    CASE(2):
      wind_direction_text = "North-northeast";
    CASE(3):
      wind_direction_text = "Northeast";
    CASE(4):
      wind_direction_text = "East-northeast";
    CASE(5):
      wind_direction_text = "East";
    CASE(6):
      wind_direction_text = "East-southeast";
    CASE(7):
      wind_direction_text = "Southeast";
    CASE(8):
      wind_direction_text = "South-southeast";
    CASE(9):
      wind_direction_text = "South";
    CASE(10):
      wind_direction_text = "South-southwest";
    CASE(11):
      wind_direction_text = "Southwest";
    CASE(12):
      wind_direction_text = "West-southwest";
    CASE(13):
      wind_direction_text = "West";
    CASE(14):
      wind_direction_text = "West-northwest";
    CASE(15):
      wind_direction_text = "Northwest";
    CASE(16):
      wind_direction_text = "North-northwest";
    DEFAULT:
      wind_direction_text = "Info Unavailable";
  }
  
  out_Wind_Direction_Text = wind_direction_text;
  
  // Wind Speed
  IF(param_Units = "f")
    MAKESTRING(units, "mph");
  ELSE IF(param_Units = "c")
    MAKESTRING(units, "km/h");
  ELSE
    units = "";
  
  MAKESTRING(out_Wind_Speed_Text, "%u %s", out_Wind_Speed, units);
  
  // Full Wind Text
  IF(out_Wind_Speed = 0)
    out_Wind_Full_Description = "Calm";
  ELSE
  {
    SWITCH(out_Wind_Direction)
    {
      CASE(1):
        wind_direction_text = "N";
      CASE(2):
        wind_direction_text = "NNE";
      CASE(3):
        wind_direction_text = "NE";
      CASE(4):
        wind_direction_text = "ENE";
      CASE(5):
        wind_direction_text = "E";
      CASE(6):
        wind_direction_text = "ESE";
      CASE(7):
        wind_direction_text = "SE";
      CASE(8):
        wind_direction_text = "SSE";
      CASE(9):
        wind_direction_text = "S";
      CASE(10):
        wind_direction_text = "SSW";
      CASE(11):
        wind_direction_text = "SW";
      CASE(12):
        wind_direction_text = "WSW";
      CASE(13):
        wind_direction_text = "W";
      CASE(14):
        wind_direction_text = "WNW";
      CASE(15):
        wind_direction_text = "NW";
      CASE(16):
        wind_direction_text = "NNW";
      DEFAULT:
        wind_direction_text = "";
    }
    
    MAKESTRING(out_Wind_Full_Description, "%s %u %s", wind_direction_text, out_Wind_Speed, units);
  }
  
  // Humidity
  element_names[1] = "yweather:atmosphere";
  XMLGetElementData(element_names, 1, received, content, attributes);
  
  IF(param_Units = "f")
    MAKESTRING(units, "in");
  ELSE IF(param_Units = "c")
    MAKESTRING(units, "mb");
  ELSE
    units = "";
  
  MAKESTRING(out_Humidity_Text, "%u%%", out_Humidity);
  
  // Pressure
  out_Humidity = ATOI(XMLGetAttributeData("humidity", attributes));
  out_Pressure = ATOI(XMLGetAttributeData("pressure", attributes));
  
  IF(param_Units = "f")
    MAKESTRING(units, "in");
  ELSE IF(param_Units = "c")
    MAKESTRING(units, "mb");
  ELSE
    units = "";
  
  MAKESTRING(out_Pressure_Text, "%u %s", out_Pressure, units);
  
  // Sunrise & Sunset
  element_names[1] = "yweather:astronomy";
  XMLGetElementData(element_names, 1, received, content, attributes);
  
  tod = XMLGetAttributeData("sunrise", attributes);
  out_Sunrise_Text = tod;
  out_Sunrise      = TIMETOI(tod);
  
  tod = XMLGetAttributeData("sunset", attributes);
  out_Sunset_Text = tod;
  out_Sunset      = TIMETOI(tod);
  
  element_names[1] = "item";
  
  // Latitude
  element_names[2] = "geo:lat";
  XMLGetElementData(element_names, 1, received, content, attributes);
  
  out_Lat_Is_North = !FIND("-", content);
  out_Lat_Degrees  = ATOI(content);
  
  find_pos = FIND(".", content);
  content = RIGHT(content, LEN(content) - find_pos);
  
  IF(LEN(content) = 2)
    out_Lat_Minutes  = MULDIV(ATOI(content), 60, 100);
  ELSE IF(LEN(content) = 1)
    out_Lat_Minutes  = MULDIV(ATOI(content), 60, 10);
  ELSE
    TRACE("weather logic.usp\n    Lat Minutes = '%s'\n", content);
  
  // Longitude
  element_names[2] = "geo:long";
  XMLGetElementData(element_names, 1, received, content, attributes);
  
  out_Long_Is_East = !FIND("-", content);
  out_Long_Degrees = ATOI(content);
  
  find_pos = FIND(".", content);
  content = RIGHT(content, LEN(content) - find_pos);
  
  IF(LEN(content) = 2)
    out_Long_Minutes  = MULDIV(ATOI(content), 60, 100);
  ELSE IF(LEN(content) = 1)
    out_Long_Minutes  = MULDIV(ATOI(content), 60, 10);
  ELSE
    TRACE("weather logic.usp\n    Long Minutes = '%s'\n", content);
  
  // Temperature
  IF(param_Units = "f")
    MAKESTRING(units, "%c", 0xB0);
  ELSE IF(param_Units = "c")
    MAKESTRING(units, "%c", 0xB0);
  ELSE
    units = "";
  
  // Current Conditions
  element_names[2] = "yweather:condition";
  XMLGetElementData(element_names, 1, received, content, attributes);
  
  out_Current_Temp  = ATOSINew(XMLGetAttributeData("temp", attributes));
  MAKESTRING(out_Current_Temp_Text, "%d%s", out_Current_Temp, units);

  out_Current_Conditions = XMLGetAttributeData("text", attributes);
  out_Current_Image      = GetImage(ATOI(XMLGetAttributeData("code", attributes)));
  
  MAKESTRING(out_Wind_Chill_Text, "%d%s", out_Wind_Chill, units);
  
  // Forecast
  element_names[2] = "yweather:forecast";
  FOR(forecast_day = 1 TO #FORECAST_DAYS)
  {
    XMLGetElementData(element_names, forecast_day, received, content, attributes);
    TRACE("Weather | Forecast %u", forecast_day);
    out_Forecast_High[forecast_day] = ATOSINew(XMLGetAttributeData("high", attributes));
    MAKESTRING(out_Forecast_High_Text[forecast_day], "%d%s", out_Forecast_High[forecast_day], units);
    
    out_Forecast_Low[forecast_day] = ATOSINew(XMLGetAttributeData("low", attributes));
    MAKESTRING(out_Forecast_Low_Text[forecast_day], "%d%s", out_Forecast_Low[forecast_day], units);
    
    out_Forecast_Description[forecast_day] = XMLGetAttributeData("text", attributes);
    out_Forecast_Image[forecast_day]       = GetImage(ATOI(XMLGetAttributeData("code", attributes)));
    
    out_Forecast_Date[forecast_day] = XMLGetAttributeData("date", attributes);
  }
}

SOCKETRECEIVE struct_TCP
{
  STRING connected_address[#ADDRESS_LEN];
  STRING received[#WEATHER_LEN];

  SOCKETGETADDRESSASREQUESTED(struct_TCP, connected_address);
  TRACE("Weather | SOCKETRECEIVE(%s), LEN=%u", connected_address, LEN(struct_TCP.SocketRxBuf));
  
  received = GATHER("</rss>", struct_TCP.SocketRxBuf);
  ProcessRX(received);
}


// Runtime
FUNCTION Main()
{
  SIGNED_INTEGER return_error;
  INTEGER i; // iterator
  
  return_error = WAITFORINITIALIZATIONCOMPLETE();
  
  IF(return_error < 0)
  {
    TRACE("ERROR in %s 'weather logic.usp': WAITFORINITALIZATIONCOMPLETE() = %d", GETSYMBOLINSTANCENAME(), return_error);
  }
  
  FOR(i = 1 TO #MAX_PRESETS)
  {
    out_Preset_Location[i] = PresetLocations[i];
    out_Preset_ZIP_Code[i] = PresetZipCodes[i];
  }

  IF(LEN(param_ZIP_Code) = #ZIP_CODE_LEN)
    ZipCode = param_ZIP_Code;
  ELSE
    ZipCode = PresetZipCodes[1];
}
